{"version":3,"sources":["src/components/flow-designer/canvas/canvas.scss?tag=goat-canvas&encapsulation=shadow","src/components/flow-designer/canvas/canvas.tsx"],"names":["canvasCss","Canvas","[object Object]","hostRef","this","unitSize","lines","padding","drawingArea","minX","minY","maxX","maxY","computedViewbox","x","y","width","height","paths","_Canvas_createStartString","set","point","updateDrawingArea","_Canvas_createQuadraticCurveString","pointA","pointB","_Canvas_createLineString","setTimeout","renderCanvas","line","drawLine","calculateViewbox","result","viewbox","split","parseInt","startConnector","start","gap","direction","endConnector","end","pathString","__classPrivateFieldGet","call","type","createStraightLinePath","createShapeConnectorPath","push","join","curveSize","position","h","Host","class","style","background-size","background-position","viewBox","map","path","stroke-width","stroke-linecap","stroke-linejoin","stroke","d","fill"],"mappings":"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","sourcesContent":["@import \"../../../globalStyles/commons\";\n\n:host {\n  display: block;\n}\n\n.canvas-wrapper {\n  background-image: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='8d8d8d' class='bi bi-dot' viewBox='0 0 16 16'%3E%3Cpath d='M8 9.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z'/%3E%3C/svg%3E\");\n  width: max-content;\n}\n\n.line {\n  stroke: v(--border-color);\n\n  &.clickable {\n    cursor: pointer;\n    &:hover {\n      stroke: v(--color-primary);\n    }\n    z-index: 1;\n  }\n}\n","import { Component, Element, h, Host, Prop, State } from '@stencil/core';\n\n@Component({\n  tag: 'goat-canvas',\n  styleUrl: 'canvas.scss',\n  shadow: true,\n})\nexport class Canvas {\n\n  @Prop() unitSize: number = 16;\n  @Prop() lines: any[] = [];\n  @Prop() padding: number = 2;\n\n  @Prop() viewbox?: string;\n\n  private drawingArea = {\n    minX: 0,\n    minY: 0,\n    maxX: 0,\n    maxY: 0,\n  };\n\n  @State() computedViewbox = {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n  };\n\n  @State() paths: string[] = [];\n\n  @Element() elm!: HTMLElement;\n\n\n  componentDidLoad() {\n    setTimeout(() => {\n      this.renderCanvas();\n    });\n  }\n\n  renderCanvas() {\n\n    for (const line of this.lines) {\n      this.drawLine(line);\n    }\n\n    this.computedViewbox = this.calculateViewbox();\n    this.paths = [...this.paths];\n  }\n\n  calculateViewbox() {\n    let result;\n    if (this.viewbox) {\n      const viewbox = this.viewbox.split(' ');\n      result = {\n        x: parseInt(viewbox[0], 10),\n        y: parseInt(viewbox[1], 10),\n        width: parseInt(viewbox[2], 10),\n        height: parseInt(viewbox[3], 10),\n      };\n    } else {\n      result = {\n        x: this.drawingArea.minX,\n        y: this.drawingArea.minY,\n        width: (this.drawingArea.maxX - this.drawingArea.minX),\n        height: (this.drawingArea.maxY - this.drawingArea.minY),\n      };\n    }\n\n    if (this.padding) {\n      result.x -= this.padding;\n      result.y -= this.padding;\n      result.width += 2 * this.padding;\n      result.height += 2 * this.padding;\n    }\n    return result;\n  }\n\n\n  drawLine(line) {\n\n    const startConnector = {\n      x: line.start.x,\n      y: line.start.y,\n    };\n    if (line.start.gap) {\n      if (line.start.direction == 'down') {\n        startConnector.y += line.start.gap;\n      } else if (line.start.direction == 'up') {\n        startConnector.y -= line.start.gap;\n      } else if (line.start.direction == 'right') {\n        startConnector.x += line.start.gap;\n      } else if (line.start.direction == 'left') {\n        startConnector.x -= line.start.gap;\n      }\n    }\n\n    const endConnector = {\n      x: line.end.x,\n      y: line.end.y,\n    };\n\n    if (line.end.gap) {\n      if (line.end.direction == 'down') {\n        endConnector.y += line.end.gap;\n      } else if (line.end.direction == 'top') {\n        endConnector.y -= line.end.gap;\n      } else if (line.end.direction == 'right') {\n        endConnector.x += line.end.gap;\n      } else if (line.end.direction == 'left') {\n        endConnector.x -= line.end.gap;\n      }\n    }\n\n    let pathString = this.#createStartString(line.start);\n\n    /**\n     * Straight line between two connectors\n     */\n    if (!line.type || line.type == 'straight_line') {\n      pathString += this.createStraightLinePath(line, startConnector, endConnector);\n    }\n\n    if (line.type == 'shape_connector') {\n      pathString += this.createShapeConnectorPath(line, startConnector, endConnector);\n    }\n\n\n    this.updateDrawingArea(line.start);\n    this.updateDrawingArea(line.end);\n\n    this.paths.push(pathString);\n\n  }\n\n  createStraightLinePath(line, startConnector, endConnector) {\n    let pathString = [];\n    pathString.push(this.#createLineString(startConnector));\n    pathString.push(this.#createLineString(endConnector));\n    pathString.push(this.#createLineString(line.end));\n    return ` ${pathString.join(' ')}`;\n  }\n\n  createShapeConnectorPath(line, startConnector, endConnector) {\n\n    let pathString = [];\n    let curveSize = 2;\n\n    if (line.start.direction == 'down') {\n      if (line.end.direction == 'top') {\n        if (startConnector.x === endConnector.x) {\n          pathString.push(this.#createLineString(line.end));\n        } else if (startConnector.x < endConnector.x) {\n          pathString.push(this.#createLineString({ x: startConnector.x, y: startConnector.y - curveSize }));\n          pathString.push(this.#createQuadraticCurveString({ x: startConnector.x, y: startConnector.y },\n            { x: startConnector.x + curveSize, y: startConnector.y }));\n\n          pathString.push(this.#createLineString({ x: endConnector.x - curveSize, y: startConnector.y }));\n          pathString.push(this.#createQuadraticCurveString({ x: endConnector.x, y: startConnector.y },\n            { x: endConnector.x, y: startConnector.y + curveSize }));\n          pathString.push(this.#createLineString(line.end));\n        } else {\n          pathString.push(this.#createLineString({ x: startConnector.x, y: startConnector.y - curveSize }));\n          pathString.push(this.#createQuadraticCurveString({ x: startConnector.x, y: startConnector.y },\n            { x: startConnector.x - curveSize, y: startConnector.y }));\n\n          pathString.push(this.#createLineString({ x: endConnector.x + curveSize, y: startConnector.y }));\n          pathString.push(this.#createQuadraticCurveString({ x: endConnector.x, y: startConnector.y },\n            { x: endConnector.x, y: startConnector.y + curveSize }));\n          pathString.push(this.#createLineString(line.end));\n        }\n      }\n    }\n\n\n    /*if (startConnector.x === endConnector.x) {\n      pathString.push(this.#createLineString(endConnector));\n    } else {\n      if (line.start.direction === 'down' && line.end.direction === 'left') {\n        if (startConnector.y < endConnector.y) {\n          pathString += ` ${this.#createLineString({ x: startConnector.x, y: endConnector.y })}`;\n        } else {\n          pathString += ` ${this.#createLineString({ x: endConnector.x, y: startConnector.y })}`;\n        }\n      }\n      pathString += ` ${this.#createLineString(endConnector)}`;\n    }*/\n    return ` ${pathString.join(' ')}`;\n  }\n\n\n  updateDrawingArea(position) {\n    if (position.x > this.drawingArea.maxX) {\n      this.drawingArea.maxX = position.x;\n    }\n    if (position.y > this.drawingArea.maxY) {\n      this.drawingArea.maxY = position.y;\n    }\n    if (position.x < this.drawingArea.minX) {\n      this.drawingArea.minX = position.x;\n    }\n    if (position.y < this.drawingArea.minY) {\n      this.drawingArea.minY = position.y;\n    }\n  }\n\n  render() {\n    return <Host>\n      <div class='canvas-wrapper' style={{\n        'background-size': `${this.unitSize}px ${this.unitSize}px`,\n        'background-position': `${this.unitSize / 2}px ${this.unitSize / 2}px`,\n      }}>\n\n        <svg class='canvas'\n             viewBox={`${this.computedViewbox.x * this.unitSize} ${this.computedViewbox.x * this.unitSize} ${this.computedViewbox.width * this.unitSize} ${this.computedViewbox.height * this.unitSize}`}>\n          {\n            (this.paths.map((path) => {\n              return <path class='line clickable'\n                           stroke-width='4'\n                           stroke-linecap='round'\n                           stroke-linejoin='round'\n                           stroke='#000'\n                           d={`${path}`}\n                           fill='none' />;\n            }))\n          }\n        </svg>\n      </div>\n    </Host>;\n  }\n\n  #createStartString: any = (point) => {\n    this.updateDrawingArea(point);\n    return `M${point.x * this.unitSize} ${point.y * this.unitSize}`;\n  };\n\n  #createQuadraticCurveString: any = (pointA, pointB) => {\n    this.updateDrawingArea(pointA);\n    this.updateDrawingArea(pointA);\n    return `Q ${pointA.x * this.unitSize} ${pointA.y * this.unitSize} ${pointB.x * this.unitSize} ${pointB.y * this.unitSize}`;\n  };\n\n  #createLineString: any = (point) => {\n    this.updateDrawingArea(point);\n    return `L${point.x * this.unitSize} ${point.y * this.unitSize}`;\n  };\n\n}\n"]}