{"version":3,"sources":["src/components/flow-designer/flow-designer/flow-designer.scss?tag=goat-flow-designer&encapsulation=shadow","src/components/flow-designer/flow-designer/flow-designer.tsx"],"names":["flowDesignerCss","PX","unit","FlowDesigner","[object Object]","hostRef","this","blockSize","activities","disabled","isMouseDown","activityHeight","activityWidth","lines","window","loadScript","start","x","y","gap","direction","end","type","setTimeout","nativeScrollElm","scrollLeft","canvasElm","clientWidth","initializeCanvas","radius","Circle","move","attr","fill","stroke","color","size","centerOfRect","Rect","addClass","h","Host","class","ref","elm","onMouseDown","event","preventDefault","startX","pageX","offsetLeft","startY","pageY","offsetTop","scrollTop","onMouseLeave","onMouseMove","walkX","walkY","padding","viewbox","style","width","getViewBoxWidth","height","getViewBoxHeight"],"mappings":"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","sourcesContent":["@import \"../../../globalStyles/commons\";\n\n:host {\n  display: block;\n  --table-border-radius: #{v(border-radius)};\n  height: 400px\n}\n\n\n.flow-designer {\n  height: 100%;\n  width: 100%;\n  overflow: hidden;\n\n  border-radius: var(--table-border-radius);\n  background-color: #{v(background-color)};\n  border: 1px solid #{v(border-color)};\n}\n\n.canvas-wrapper {\n  @include font-style(text-md);\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n\n.flow-lines, .flow-items {\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n\n.flow-items {\n  position: absolute;\n  top: 0;\n  left: 50%;\n  pointer-events: none;\n}\n\n.activity {\n  fill: v(--background);\n  stroke: v(--border-color);\n}\n\n.flow-designer {\n\n  /* border: 1px solid v(color-neutral-30);\n   box-sizing: border-box;\n   border-radius: var(--table-border-radius);\n   overflow:hidden;\n   height: 100%;\n   .flow-scroll-wrapper {\n     position: relative;\n     z-index: v(z-index-table-header);\n     overflow: hidden;\n     height: 100%;\n     width: 100%;\n     min-height: 20em;\n\n     .flow {\n       display: flex;\n       align-items: center;\n       justify-content: center;\n       user-select: none;\n       cursor: grab;\n       position: absolute;\n       min-height: 300rem;\n       min-width: 300rem;\n       background: v(color-neutral-10);\n     }\n   }\n\n   .start-activity {\n\n   }*/\n}\n","import { Component, Element, h, Host, Listen, Prop, State } from '@stencil/core';\nimport { loadScript } from '../../../utils/utils';\n\n\nfunction PX(unit: number) {\n  return unit * 16;\n}\n\n/**\n * @name Flow Designer\n * @description An interactive button with a range of presentation options.\n * @example <goat-flow-designer>\n *   </goat-flow-designer>\n */\n@Component({\n  tag: 'goat-flow-designer',\n  styleUrl: 'flow-designer.scss',\n  shadow: true,\n})\nexport class FlowDesigner {\n\n  @Element() elm!: HTMLElement;\n\n  @Prop() blockSize: number = 10;\n\n  @Prop() activities: any[] = [];\n\n  @Prop() disabled: boolean = false;\n\n  private isMouseDown: boolean = false;\n  private startX: number;\n  private startY: number;\n  private scrollLeft: number;\n  private scrollTop: number;\n\n  private nativeScrollElm?: HTMLElement;\n  private canvasElm?: HTMLElement;\n\n  @State() activityHeight: number = 10;\n  @State() activityWidth: number = 5;\n  @State() lines: any[] = [];\n\n  @Listen('mouseup', { passive: false })\n  handleMouseDown() {\n    this.isMouseDown = false;\n  }\n\n  async componentWillLoad() {\n    if (!window['SVG']) {\n      await loadScript(`https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.1.2/svg.min.js`);\n    }\n    this.lines = [{\n      start: { x: 0, y: 0, gap: 8, direction: 'down' },\n      end: { x: -15, y: 15, direction: 'top' },\n      type: 'shape_connector',\n    }, {\n      start: { x: 0, y: 0, gap: 8, direction: 'down' },\n      end: { x: 15, y: 15, direction: 'top' },\n      type: 'shape_connector',\n    }];\n  }\n\n  componentDidLoad() {\n\n    setTimeout(() => {\n      this.nativeScrollElm.scrollLeft = (this.canvasElm.clientWidth - this.nativeScrollElm.clientWidth) / 2;\n      this.initializeCanvas();\n    }, 100);\n  }\n\n  getViewBoxHeight() {\n    return PX(this.blockSize * this.activityHeight);\n  }\n\n  getViewBoxWidth() {\n    return PX(this.blockSize * this.activityWidth);\n  }\n\n  initializeCanvas() {\n    //  const draw = (window['SVG']()).addTo(this.canvasElm).viewbox(0, 0, this.getViewBoxWidth(), this.getViewBoxHeight());\n\n    // this.createActivityNode(1, 1).addTo(draw);\n\n  }\n\n  createStartNode() {\n    const radius = PX(this.blockSize / 2);\n\n    return (new window['SVG'].Circle())\n      .radius(radius).move(0, 0)\n      .attr({ fill: 'var(--color-success-100)' })\n      .stroke({ color: 'var(--color-success-500)' });\n  }\n\n  createActivityNode(x, y) {\n    const size = PX(this.blockSize / 2);\n\n    /* var image = new window['SVG'].Image().load('https://cdn.img42.com/4b6f5e63ac50c95fe147052d8a4db676.jpeg');\n     image.size(100, 100).move(20, 20);*/\n\n    const centerOfRect = (size / 2);\n    return (new window['SVG'].Rect())\n      .addClass('activity')\n      .size(size, size)\n      .radius(15)\n      .move((((this.activityWidth - 1) / 2 + x) * PX(this.blockSize)) + centerOfRect, ((y) * PX(this.blockSize)) + centerOfRect);\n  }\n\n  render() {\n    return <Host disabled={this.disabled}>\n      <div class='flow-designer' ref={elm => this.nativeScrollElm = elm}>\n        <div class='canvas-wrapper'\n             onMouseDown={(event) => {\n               event.preventDefault();\n               this.isMouseDown = true;\n               this.startX = event.pageX - this.nativeScrollElm.offsetLeft;\n               this.startY = event.pageY - this.nativeScrollElm.offsetTop;\n               this.scrollLeft = this.nativeScrollElm.scrollLeft;\n               this.scrollTop = this.nativeScrollElm.scrollTop;\n             }}\n             onMouseLeave={(event) => {\n               event.preventDefault();\n               this.isMouseDown = false;\n             }}\n             onMouseMove={(event) => {\n               event.preventDefault();\n               if (!this.isMouseDown) return;\n               const x = event.pageX - this.nativeScrollElm.offsetLeft;\n               const walkX = (x - this.startX); //scroll-fast\n               this.nativeScrollElm.scrollLeft = this.scrollLeft - walkX;\n               const y = event.pageY - this.nativeScrollElm.offsetTop;\n               const walkY = (y - this.startY); //scroll-fast\n               this.nativeScrollElm.scrollTop = this.scrollTop - walkY;\n             }}>\n\n          <goat-canvas ref={elm => this.canvasElm = elm} class='flow-lines' lines={this.lines} padding={0}\n                       viewbox={`0 0 124 134`} />\n\n          <div class='flow-items'\n               style={{ 'width': `${this.getViewBoxWidth()}px`, 'height': `${this.getViewBoxHeight()}px` }} />\n        </div>\n      </div>\n    </Host>;\n  }\n\n\n  /* renderCanvas() {\n     console.log(this.canvasElm);\n     const draw = (window['SVG']())\n       .addTo(this.canvasElm);\n\n     const panel = {\n       minX: 0,\n       minY: 0,\n       maxX: 0,\n       maxY: 0,\n     };\n\n     for (const line of this.lines) {\n       this.drawLine(draw, line, panel);\n     }\n\n     panel.minX -= 1;\n     panel.minY -= 1;\n     panel.maxX += 1;\n     panel.maxY += 1;\n\n     this.width = (panel.maxX - panel.minX);\n     this.height = (panel.maxY - panel.minY);\n\n     draw.viewbox(panel.minX * this.unitSize, panel.minY * this.unitSize, this.width * this.unitSize, this.height * this.unitSize);\n   }\n\n\n   drawLine(draw, line, panel) {\n\n     let pathString = `M${(line.start.x) * this.unitSize} ${(line.start.y) * this.unitSize}`;\n     this.updatePanel(panel, line.start);\n\n     const currentPosition = { x: line.start.x, y: line.start.y };\n     for (let i = 0; i < line.path.length; i++) {\n       const step = line.path[i];\n       const nextStep = line.path[i + 1];\n       if (step.move === 'down' || step.move === 'up') {\n         if (step.move === 'down') {\n           currentPosition.y += step.size * this.stepSize;\n         } else if (step.move === 'up') {\n           currentPosition.y += -1 * step.size * this.stepSize;\n         }\n\n         if (nextStep && (nextStep.move === 'left' || nextStep.move === 'right')) {\n\n           if (step.move == 'down' && nextStep.move === 'right') {\n             currentPosition.x += -1 * step.size * this.stepSize;\n           } else if (nextStep.move === 'right') {\n             currentPosition.x += step.size * this.stepSize;\n           }\n           pathString +=\n\n           /!* draw.path('M0 16 Q 0 48 32 48')\n              .fill('none')\n              .stroke({ color: '#f06', width: 4, linecap: 'round', linejoin: 'round' }); *!/\n\n         } else {\n           pathString += ` V ${currentPosition.y * this.unitSize}`;\n         }\n       } else if (step.move === 'right' || step.move === 'left') {\n         if (step.move === 'left') {\n           currentPosition.x += -1 * step.size * this.stepSize;\n         } else if (step.move === 'right') {\n           currentPosition.x += step.size * this.stepSize;\n         }\n\n         if (nextStep && (nextStep.move === 'up' || nextStep.move === 'down')) {\n\n         } else {\n           pathString += ` H ${currentPosition.x * this.unitSize}`;\n         }\n       }\n       this.updatePanel(panel, currentPosition);\n     }\n\n     const path = draw.path(pathString)\n       .addClass('line')\n       .addClass('clickable')\n       .fill('none')\n       .stroke({ width: 4, linecap: 'round', linejoin: 'round' });\n\n     path.node.onclick = () => {\n       alert('click');\n     };\n   }\n\n   updatePanel(panel, position) {\n     if (position.x > panel.maxX) {\n       panel.maxX = position.x;\n     }\n     if (position.y > panel.maxY) {\n       panel.maxY = position.y;\n     }\n     if (position.x < panel.minX) {\n       panel.minX = position.x;\n     }\n     if (position.y < panel.minY) {\n       panel.minY = position.y;\n     }\n   }*/\n\n}\n"]}